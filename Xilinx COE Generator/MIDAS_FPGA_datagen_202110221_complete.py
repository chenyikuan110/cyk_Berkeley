# .coe Xilinx memory file generator
# By: Yikuan Chen
#     2021, Oct
# Press Shift+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.


import numpy as np
import os
import matplotlib.pyplot as pyplot


def sine_test_pattern(length, freq, timestep, relative_amp, nbits, phase_offset_deg, quantization_mode):
    y = np.zeros(length)
    phase_offset = phase_offset_deg / 180 * np.pi
    for i in range(length):
        # number range [0,1]
        y[i] = relative_amp / 2 * np.sin(2 * np.pi * freq * timestep * i - phase_offset) +  0.5
    # quantize to n-bit integer
    if quantization_mode == "truncate":
        y = np.floor(y * 0.9999999999 * (2 ** nbits))  # to prevent overflow
    else:
        y = np.round(y * (2 ** nbits -1))
    return y.astype(int)


def int2bin(num, nbits):
    b = np.zeros(nbits)
    if num > 2**nbits-1 or num < 0:
        print(str(num) + " cannot be represented by "+str(nbits)+" binary!")
    else:
        # print(str(num) + ":")
        for i in range(nbits):
            b[i] = num % 2  # TODO:LSB on the leftmost side!!!
            num = np.floor(num / 2)
    # print(str(b))
    return b

def intArray_to_binary(array, nbits):
    length = len(array)
    b = np.zeros((length, nbits))
    for i in range(length):
        b[i] = int2bin(array[i],nbits)
    # print(b)
    return b

def zip_I_and_Q(I, Q):
    I_length = len(I)
    Q_length = len(Q)
    length = max(I_length,Q_length)

    I_nbits = len(I[0])
    Q_nbits = len(Q[0])

    nbits = I_nbits + Q_nbits

    y = np.zeros((length, nbits))
    for i in range(length):
        if i < I_length:
            y[i][0:I_nbits] = I[i]
        if i < Q_length:
            y[i][I_nbits:nbits] = Q[i]
        print(y[i])
    print("["+"I. "*I_nbits+"Q. "*Q_nbits+"]")
    print("LSB<" + "--" * I_nbits + ">MSB LSB<"+"--" * Q_nbits + ">MSB")
    return y


# bram stores bits in the following format:
# I[0][serdes_bitwidth-1:0], I[1][serdes_bitwidth-1:0] ...
def binary_to_bram(b,bram_data_width, serdes_data_width):
    array_length = len(b)
    nbits = 0
    if len(b):
        if len(b[0]):
            nbits = len(b[0])
    print("test sequence length = "+str(array_length))
    if nbits == 0:
        print("Error with input array")
        return

    # begin real code
    num_taps = int(serdes_data_width / 2)  # for MIDAS, it's 16
    bram_max_addr = int(np.ceil(array_length / num_taps))
    print("bram_max_addr:"+str(bram_max_addr))
    print("num_taps per output:" + str(num_taps))
    print("nbits I+Q zipped:" + str(nbits))
    output_matrix = np.zeros((bram_max_addr, bram_data_width))

    for i in range(bram_max_addr):
        for j in range(nbits):
            for k in range(num_taps):
                # if sequence length < max_address * num_taps_per_address
                # the rest of the bits will be set to 0
                if i*num_taps + k < array_length:
                    output_matrix[i][j*num_taps+k] = b[i*num_taps + k][j]

    return output_matrix, bram_max_addr


# turn a 0,1 matrix into binary or hex string
# string_type can be 'bin' or 'hex'
def bin_to_string(matrix, string_type='bin', prefix=''):

    if len(matrix) == 0:
        print("Invalid matrix input!")
        return -1
    matrix_height = len(matrix)
    line_width = len(matrix[0])

    # pad the matrix so each line has 4*N bits
    if line_width % 4 != 0:
        matrix = np.hstack((matrix, np.zeros((matrix_height, 4 - line_width % 4))))
        line_width = len(matrix[0])

    matrix = matrix.astype(int)
    num_hex_digits = int(line_width / 4)

    output = []

    for i in range(matrix_height):
        reversed_bit_array = matrix[i][::-1]  # put LSB on rightmost side
        binary_string = ''.join(map(str, reversed_bit_array))  # turn array into string
        if string_type == 'hex':
            hex_val = '%.*x' % (num_hex_digits, int('0b'+binary_string, 0))
            hex_val = prefix+hex_val
            output.append(hex_val)
        else:
            output.append(binary_string)

    return output




# write our matrix to Xilinx .coe memory file
# radix can be 16 or 2
def write_to_coe(string, radix, output_file_path, output_file_name):
    full_file_path = os.path.join(output_file_path, output_file_name)

    # create results folder path & config file if it does not exist
    if not os.path.exists(output_file_path):
        os.makedirs(output_file_path)

    fp = open(full_file_path,'w')
    # headers
    fp.write(";This .coe file is generated by third party script\n")
    fp.write(";script written by Yikuan Chen in Oct 2021\n")
    fp.write(";for the purpose of MIDAS Tx test only\n")
    fp.write("memory_initialization_radix="+str(radix)+";\n")
    fp.write("memory_initialization_vector=")

    for line in string[:-1]:
        fp.write("{},\n".format(line))
    fp.write("{};".format(string[-1]))

    fp.close()

    return

#########################
# Main below
#########################
fOS = 5e9               # for MIDAS it's 5 GHz
fIF = 0.25e9            # for MIDAS it's 250 MHz
nbits = 10               # for MIDAS it's 10
round_mode = "round"    # round or truncate
relative_amp = 1        # 0 < relative_amp <= 1
timestep = 1 / fOS

sequence_length = 128  # number of samples,
serdes_data_width = 32  # for MIDAS it's 32
bram_data_width = int(2**(np.ceil(np.log2(serdes_data_width/2*nbits*2))))
# bram_data_width = 512  # for MIDAS it's 512 = 2^(ceil(logbase2(serdes_data_width / 2 *nbits * 2)))

# coe file related
output_file_path = '.\COE'
additional_info = ''
output_file_name = 'test_vector_dacWidth'+str(nbits)+'_serdesWidth'+str(serdes_data_width)+additional_info+'.coe'

# run code

time = np.linspace(0, timestep * sequence_length, sequence_length)

I_data = sine_test_pattern(sequence_length, fIF, timestep, relative_amp, nbits, phase_offset_deg=0, quantization_mode=round_mode)
Q_data = sine_test_pattern(sequence_length, fIF, timestep, relative_amp*0.8, nbits, phase_offset_deg=30, quantization_mode=round_mode)

I_data_bits = intArray_to_binary(I_data, nbits)
Q_data_bits = intArray_to_binary(Q_data, nbits)

zipped_data_bits = zip_I_and_Q(I_data_bits,Q_data_bits)

print("\n\nserdes_data_width per lane:"+str(int(serdes_data_width))+" (serial output @ "+str(fOS/1e9)+"GHz)")
print("requested # of taps per lane:"+str(int(serdes_data_width/2))+" (loaded @ "+str(fOS/(serdes_data_width/2)/1e9)+"GHz)")
print("bram_data_width:"+str(bram_data_width) +
      "(> serdes_data_width/2*nbits*2 = "
      +str(serdes_data_width)+"*"+str(nbits)+" = "+str(serdes_data_width*nbits)+")")

output_matrix, bram_max_addr = binary_to_bram(zipped_data_bits,bram_data_width, serdes_data_width)

print("\noutput bit to be stored in bram:")
print(output_matrix)

hex_string = bin_to_string(output_matrix, 'hex', prefix='')
assert len(hex_string) == bram_max_addr

write_to_coe(hex_string, 16, output_file_path, output_file_name)

pyplot.step(time * 1e9, I_data, where="post")
pyplot.plot(time * 1e9, I_data, label="I_data")
pyplot.plot(time*1e9, Q_data, label="Q_data")
pyplot.legend()
pyplot.xlabel("ns")
pyplot.title("DAC data generation with f_IF=" + str(fIF / 1e6) + " MHz\n"
                                                                " and f_OS=" + str(fOS / 1e9) + " GHz\n"
                                                                " Max val =" + str(max(I_data)) + "\n"
                                                                " Min val =" + str(min(I_data)) + "\n"
                                                                " Quantization level = "+str(nbits)+" bits")
pyplot.tight_layout()
pyplot.show()
